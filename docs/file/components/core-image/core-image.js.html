<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">components/core-image/core-image.js | thanos</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Team 05 code repo"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="thanos"><meta property="twitter:description" content="Team 05 code repo"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ucsd-cse112/thanO5"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">components/core-image/core-image.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {on, off, getScrollContainer, isInContainer} from &apos;../../element-helpers/utils/dom&apos;;
import {isString, isHtmlElement} from &apos;../../element-helpers/utils/types&apos;;
import {throttle} from &apos;throttle-debounce&apos;;
import styleString from &apos;./core-image.scss&apos;;

// create style element
const style = document.createElement(&apos;style&apos;);
style.innerHTML = styleString;

// Helper function: determine if the browser supports object-fit css rule
const isSupportObjectFit = () =&gt; document.documentElement.style.objectFit !== undefined;

// object-fit valid values
const ObjectFit = {
  NONE: &apos;none&apos;,
  CONTAIN: &apos;contain&apos;,
  COVER: &apos;cover&apos;,
  FILL: &apos;fill&apos;,
  SCALE_DOWN: &apos;scale-down&apos;,
};

/**
 * An image with lazy-loading option
 */
class CoreImage extends HTMLElement {
  /**
   * Initialize private fields, shadowRoot and the view
   */
  constructor() {
    super();

    this._src = this.getAttribute(&apos;src&apos;) || undefined;
    this._fit = this.getAttribute(&apos;fit&apos;) || undefined;
    this._lazy = this.hasAttribute(&apos;lazy&apos;) || false;

    this._loading = true;
    this._error = false;

    this._show = !this._lazy;
    this._imageWidth = 0;
    this._imageHeight = 0;
    this._scrollContainer = {};
    this._isServer = !(typeof window != &apos;undefined&apos; &amp;&amp; window.document);

    this._template = document.createElement(&apos;template&apos;);
    this.attachShadow({mode: &apos;open&apos;});
    this._updateTemplate();
  }

  /**
   * Handle lazy-loading option when the element is appended to the DOM
   */
  connectedCallback() {
    if (this.lazy) {
      this._addLazyLoadListener();
    } else {
      this._loadImage();
    }
  }

  /**
   * Clean up possible lazy loading linsteners
   * when the element is disconnected with the DOM
   */
  disconnectedCallback() {
    this.lazy &amp;&amp; this._removeLazyLoadListener();
  }

  /**
   * The image source URL
   */
  get src() {
    return this._src;
  }

  set src(val) {
    if (typeof val === &apos;string&apos;) {
      this._src = val;
      this.setAttribute(&apos;src&apos;, val);
    } else {
      this._src = undefined;
      this.removeAttribute(&apos;src&apos;);
    }

    this._updateTemplate();
    this._show &amp;&amp; this._loadImage();
  }

  /**
   * The object-fit mode
   * &lt;br&gt; chosen from [none, contain, cover, fill, scale-down]
   */
  get fit() {
    return this._fit;
  }

  set fit(val) {
    if ([&apos;fill&apos;, &apos;contain&apos;, &apos;cover&apos;, &apos;none&apos;, &apos;scale-down&apos;].indexOf(val) &gt; -1) {
      this._fit = val;
      this.setAttribute(&apos;fit&apos;, val);
    } else {
      this._fit = undefined;
      this.removeAttribute(&apos;fit&apos;);
    }

    this._updateTemplate();
  }

  /**
   * If the lazy loading option is turned on
   */
  get lazy() {
    return this._lazy;
  }

  set lazy(val) {
    if (val === true) {
      this._lazy = true;
      this.setAttribute(&apos;lazy&apos;, &apos;&apos;);
    } else {
      this._lazy = false;
      this.removeAttribute(&apos;lazy&apos;);
    }
  }

  /**
   * Whether the image is still loading
   */
  get loading() {
    return this._loading;
  }

  /**
   * loading setter
   * @param {*} val
   */
  set loading(val) {
    this._loading = val;
  }

  /**
   * Whether an error is detected when the image is beging loaded
   */
  get error() {
    return this._error;
  }

  set error(val) {
    this._error = val;
  }

  /**
   * CSS style of the image element
   */
  get imageStyle() {
    if (!this._isServer &amp;&amp; this.fit) {
      if (isSupportObjectFit()) {
        return `object-fit:${this.fit}`;
      } else {
        const _imageStyle = this._getImageStyle(this.fit);
        return _imageStyle.substr(1, _imageStyle.length - 2);
      }
    }
    return &apos;&apos;;
  }

  /**
   * If the image should aligned at the center
   */
  get alignCenter() {
    return !this._isServer &amp;&amp; !isSupportObjectFit() &amp;&amp; this.fit !== ObjectFit.FILL;
  }

  /**
   * Update the template so as to update the view
   */
  _updateTemplate() {
    let templateString;
    if (this.loading) {
      templateString = `
        &lt;slot name=&quot;placeholder&quot;&gt;
          &lt;div class=&quot;el-image__placeholder&quot;&gt;&lt;/div&gt;
        &lt;/slot&gt;
      `;
    } else if (this.error) {
      templateString = `
        &lt;slot name=&quot;error&quot;&gt;
          &lt;div class=&quot;el-image__error&quot;&gt;&lt;/div&gt;
        &lt;/slot&gt;
      `;
    } else {
      let classAttr;
      if (this.alignCenter) {
        classAttr = `class=&quot;el-image__inner--center&quot;`;
      } else {
        classAttr = &apos;&apos;;
      }

      let imageStyleAttr;
      if (this.imageStyle !== {}) {
        imageStyleAttr = `style=${this.imageStyle}`;
      } else {
        imageStyleAttr = &apos;&apos;;
      }

      templateString = `
        &lt;img
          class=&quot;el-image__inner&quot;
          src=${this.src}
          ${imageStyleAttr}
          ${classAttr}&gt;
      `;
    }

    this._template.innerHTML = templateString;
    this.shadowRoot.innerHTML = &apos;&apos;;
    this.shadowRoot.appendChild(this._template.content);
    this.shadowRoot.appendChild(style.cloneNode(true));
  }

  /**
   * Loading the image
   */
  _loadImage() {
    if (this._isServer) return;
    // reset status
    this.loading = true;
    this.error = false;
    const img = new Image();
    img.onload = (e) =&gt; this._handleLoad(e, img);
    img.onerror = this._handleError.bind(this);
    // If no src specified, an error appears in the console (this is the expected behavior)

    img.src = this.src;
  }

  /**
   * Handle image-loaded event
   * @param {Object} e the image-loaded event
   * @param {Object} img the img element
   */
  _handleLoad(e, img) {
    this.imageWidth = img.width;
    this.imageHeight = img.height;
    this.loading = false;
    this._updateTemplate();
  }

  /**
   * Handle error event
   * @param {Object} e the error event
   */
  _handleError(e) {
    this.loading = false;
    this.error = true;
    this._updateTemplate();
    // this.$emit(&apos;error&apos;, e);
  }

  /**
   * Load the image in the lazy-loading fashion
   */
  _handleLazyLoad() {
    if (isInContainer(this, this._scrollContainer)) {
      this.show = true;
      this._loadImage();
      this._removeLazyLoadListener();
    }
  }

  /**
   * Add a lazy loading linstener that listenes to lazy-loaded event
   */
  _addLazyLoadListener() {
    if (this._isServer) return;
    const {scrollContainer} = this;
    let _scrollContainer = null;
    if (isHtmlElement(scrollContainer)) {
      _scrollContainer = scrollContainer;
    } else if (isString(scrollContainer)) {
      _scrollContainer = document.querySelector(scrollContainer);
    } else {
      _scrollContainer = getScrollContainer(this);
    }
    if (_scrollContainer) {
      this._scrollContainer = _scrollContainer;
      this._lazyLoadHandler = throttle(500, this._handleLazyLoad.bind(this));
      on(_scrollContainer, &apos;scroll&apos;, this._lazyLoadHandler);
      this._handleLazyLoad();
    }
  }

  /**
   * Remove the lazy loading linstener
   */
  _removeLazyLoadListener() {
    const {_scrollContainer, _lazyLoadHandler} = this;
    if (this._isServer || !_scrollContainer || !_lazyLoadHandler) return;
    off(_scrollContainer, &apos;scroll&apos;, _lazyLoadHandler);
    this._scrollContainer = null;
    this._lazyLoadHandler = null;
  }

  /**
   * simulate object-fit behavior to compatible with IE11 and other browsers which not support object-fit
   * @param {string} fit the object-fit mode
   * @return {Object}
   */
  _getImageStyle(fit) {
    // const {_imageWidth, _imageHeight} = this;
    const {
      clientWidth: containerWidth,
      clientHeight: containerHeight,
    } = this;
    if (!imageWidth || !imageHeight || !containerWidth || !containerHeight) return {};
    const vertical = imageWidth / imageHeight &lt; 1;
    if (fit === ObjectFit.SCALE_DOWN) {
      const isSmaller = imageWidth &lt; containerWidth &amp;&amp; imageHeight &lt; containerHeight;
      fit = isSmaller ? ObjectFit.NONE : ObjectFit.CONTAIN;
    }
    switch (fit) {
      case ObjectFit.NONE:
        return {width: &apos;auto&apos;, height: &apos;auto&apos;};
      case ObjectFit.CONTAIN:
        return vertical ? {width: &apos;auto&apos;} : {height: &apos;auto&apos;};
      case ObjectFit.COVER:
        return vertical ? {height: &apos;auto&apos;} : {width: &apos;auto&apos;};
      default:
        return {};
    }
  }
}

// Register the web component
if (!customElements.get(&apos;core-image&apos;)) {
  customElements.define(&apos;core-image&apos;, CoreImage);
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
